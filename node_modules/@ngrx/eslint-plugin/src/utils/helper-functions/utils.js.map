{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../../../../modules/eslint-plugin/src/utils/helper-functions/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import type { TSESLint, TSESTree } from '@typescript-eslint/experimental-utils';\nimport { ASTUtils } from '@typescript-eslint/experimental-utils';\nimport {\n  isCallExpression,\n  isIdentifier,\n  isIdentifierOrMemberExpression,\n  isImportDeclaration,\n  isImportDefaultSpecifier,\n  isImportNamespaceSpecifier,\n  isImportSpecifier,\n  isLiteral,\n  isMethodDefinition,\n  isProgram,\n  isProperty,\n  isPropertyDefinition,\n  isTSTypeAnnotation,\n  isTSTypeReference,\n  isTemplateElement,\n  isTemplateLiteral,\n  isTSInstantiationExpression,\n} from './guards';\nimport { NGRX_MODULE_PATHS } from './ngrx-modules';\n\ntype ConstructorFunctionExpression = TSESTree.FunctionExpression & {\n  parent: TSESTree.MethodDefinition & { kind: 'constructor' };\n};\ntype InjectedParameter =\n  | TSESTree.Identifier & {\n      typeAnnotation: TSESTree.TSTypeAnnotation;\n      parent:\n        | ConstructorFunctionExpression\n        | (TSESTree.TSParameterProperty & {\n            parent: ConstructorFunctionExpression;\n          })\n        | TSESTree.PropertyDefinition;\n    };\ntype InjectedParameterWithSourceCode = Readonly<{\n  identifiers?: readonly InjectedParameter[];\n  sourceCode: Readonly<TSESLint.SourceCode>;\n}>;\n\nexport function getNearestUpperNodeFrom<T extends TSESTree.Node>(\n  { parent }: TSESTree.Node,\n  predicate: (parent: TSESTree.Node) => parent is T\n): T | undefined {\n  while (parent && !isProgram(parent)) {\n    if (predicate(parent)) {\n      return parent;\n    }\n\n    parent = parent.parent;\n  }\n\n  return undefined;\n}\n\nexport function getImportDeclarationSpecifier(\n  importDeclarations: readonly TSESTree.ImportDeclaration[],\n  importName: string\n) {\n  for (const importDeclaration of importDeclarations) {\n    const importSpecifier = importDeclaration.specifiers.find(\n      (importClause): importClause is TSESTree.ImportSpecifier => {\n        return (\n          isImportSpecifier(importClause) &&\n          importClause.imported.name === importName\n        );\n      }\n    );\n\n    if (importSpecifier) {\n      return { importDeclaration, importSpecifier } as const;\n    }\n  }\n\n  return undefined;\n}\n\nexport function getImportDeclarations(\n  node: TSESTree.Node,\n  moduleName: string\n): readonly TSESTree.ImportDeclaration[] | undefined {\n  let parentNode: TSESTree.Node | undefined = node;\n\n  while (parentNode && !isProgram(parentNode)) {\n    parentNode = parentNode.parent;\n  }\n\n  return parentNode?.body.filter((node): node is TSESTree.ImportDeclaration => {\n    return isImportDeclaration(node) && node.source.value === moduleName;\n  });\n}\n\nfunction getCorrespondentImportClause(\n  importDeclarations: readonly TSESTree.ImportDeclaration[],\n  compatibleWithTypeOnlyImport = false\n) {\n  let importClause: TSESTree.ImportClause | undefined;\n\n  for (const { importKind, specifiers } of importDeclarations) {\n    const lastImportSpecifier = getLast(specifiers);\n\n    if (\n      (!compatibleWithTypeOnlyImport && importKind === 'type') ||\n      isImportNamespaceSpecifier(lastImportSpecifier)\n    ) {\n      continue;\n    }\n\n    importClause = lastImportSpecifier;\n  }\n\n  return importClause;\n}\n\nexport function getImportAddFix({\n  compatibleWithTypeOnlyImport = false,\n  fixer,\n  importName,\n  moduleName,\n  node,\n}: {\n  compatibleWithTypeOnlyImport?: boolean;\n  fixer: TSESLint.RuleFixer;\n  importName: string;\n  moduleName: string;\n  node: TSESTree.Node;\n}): TSESLint.RuleFix | TSESLint.RuleFix[] {\n  const fullImport = `import { ${importName} } from '${moduleName}';\\n`;\n  const importDeclarations = getImportDeclarations(node, moduleName);\n\n  if (!importDeclarations?.length) {\n    return fixer.insertTextAfterRange([0, 0], fullImport);\n  }\n\n  const importDeclarationSpecifier = getImportDeclarationSpecifier(\n    importDeclarations,\n    importName\n  );\n\n  if (importDeclarationSpecifier) {\n    return [];\n  }\n\n  const importClause = getCorrespondentImportClause(\n    importDeclarations,\n    compatibleWithTypeOnlyImport\n  );\n\n  if (!importClause) {\n    return fixer.insertTextAfterRange([0, 0], fullImport);\n  }\n\n  const replacementText = isImportDefaultSpecifier(importClause)\n    ? `, { ${importName} }`\n    : `, ${importName}`;\n  return fixer.insertTextAfter(importClause, replacementText);\n}\n\nexport function getImportRemoveFix(\n  sourceCode: Readonly<TSESLint.SourceCode>,\n  importDeclarations: readonly TSESTree.ImportDeclaration[],\n  importedName: string,\n  fixer: TSESLint.RuleFixer\n): TSESLint.RuleFix | TSESLint.RuleFix[] {\n  const { importDeclaration, importSpecifier } =\n    getImportDeclarationSpecifier(importDeclarations, importedName) ?? {};\n\n  if (!importDeclaration || !importSpecifier) {\n    return [];\n  }\n\n  const isFirstImportSpecifier =\n    importDeclaration.specifiers[0] === importSpecifier;\n  const isLastImportSpecifier =\n    getLast(importDeclaration.specifiers) === importSpecifier;\n  const isSingleImportSpecifier =\n    isFirstImportSpecifier && isLastImportSpecifier;\n\n  if (isSingleImportSpecifier) {\n    return fixer.remove(importDeclaration);\n  }\n\n  const tokenAfterImportSpecifier = sourceCode.getTokenAfter(importSpecifier);\n\n  if (isFirstImportSpecifier && tokenAfterImportSpecifier) {\n    return fixer.removeRange([\n      importSpecifier.range[0],\n      tokenAfterImportSpecifier.range[1],\n    ]);\n  }\n\n  const tokenBeforeImportSpecifier = sourceCode.getTokenBefore(importSpecifier);\n\n  if (!tokenBeforeImportSpecifier) {\n    return [];\n  }\n\n  return fixer.removeRange([\n    tokenBeforeImportSpecifier.range[0],\n    importSpecifier.range[1],\n  ]);\n}\n\nexport function getNodeToCommaRemoveFix(\n  sourceCode: Readonly<TSESLint.SourceCode>,\n  fixer: TSESLint.RuleFixer,\n  node: TSESTree.Node\n) {\n  const nextToken = sourceCode.getTokenAfter(node);\n  const isNextTokenComma = nextToken && ASTUtils.isCommaToken(nextToken);\n  return [\n    fixer.remove(node),\n    ...(isNextTokenComma ? [fixer.remove(nextToken)] : []),\n  ] as const;\n}\n\nexport function getInterfaceName(\n  interfaceMember: TSESTree.Identifier | TSESTree.MemberExpression\n): string | undefined {\n  if (isIdentifier(interfaceMember)) {\n    return interfaceMember.name;\n  }\n\n  return isIdentifier(interfaceMember.property)\n    ? interfaceMember.property.name\n    : undefined;\n}\n\nexport function getInterfaces({\n  implements: classImplements,\n}: TSESTree.ClassDeclaration): readonly (\n  | TSESTree.Identifier\n  | TSESTree.MemberExpression\n)[] {\n  return (classImplements ?? [])\n    .map(({ expression }) => expression)\n    .filter(isIdentifierOrMemberExpression);\n}\n\nexport function getInterface(\n  node: TSESTree.ClassDeclaration,\n  interfaceName: string\n): TSESTree.Identifier | TSESTree.MemberExpression | undefined {\n  return getInterfaces(node).find(\n    (interfaceMember) => getInterfaceName(interfaceMember) === interfaceName\n  );\n}\n\nexport function getImplementsSchemaFixer(\n  { id, implements: classImplements }: TSESTree.ClassDeclaration,\n  interfaceName: string\n) {\n  const [implementsNodeReplace, implementsTextReplace] = classImplements\n    ? [getLast(classImplements), `, ${interfaceName}`]\n    : [id as TSESTree.Identifier, ` implements ${interfaceName}`];\n\n  return { implementsNodeReplace, implementsTextReplace } as const;\n}\n\nexport function getLast<T extends readonly unknown[]>(items: T): T[number] {\n  return items.slice(-1)[0];\n}\n\nexport function getDecoratorName({\n  expression,\n}: TSESTree.Decorator): string | undefined {\n  if (isIdentifier(expression)) {\n    return expression.name;\n  }\n\n  return isCallExpression(expression) && isIdentifier(expression.callee)\n    ? expression.callee.name\n    : undefined;\n}\n\nexport function getRawText(node: TSESTree.Node): string | null {\n  if (isIdentifier(node)) {\n    return node.name;\n  }\n\n  if (\n    isPropertyDefinition(node) ||\n    isMethodDefinition(node) ||\n    isProperty(node)\n  ) {\n    return getRawText(node.key);\n  }\n\n  if (isLiteral(node)) {\n    return node.raw;\n  }\n\n  if (isTemplateElement(node)) {\n    return `\\`${node.value.raw}\\``;\n  }\n\n  if (isTemplateLiteral(node)) {\n    return `\\`${node.quasis[0].value.raw}\\``;\n  }\n\n  return null;\n}\n\nexport function capitalize<T extends string>(text: T): Capitalize<T> {\n  return `${text[0].toUpperCase()}${text.slice(1)}` as Capitalize<T>;\n}\n\nfunction getInjectedParametersWithSourceCode(\n  context: TSESLint.RuleContext<string, readonly unknown[]>,\n  moduleName: string,\n  importName: string\n): InjectedParameterWithSourceCode {\n  const sourceCode = context.getSourceCode();\n  const importDeclarations =\n    getImportDeclarations(sourceCode.ast, moduleName) ?? [];\n  const { importSpecifier } =\n    getImportDeclarationSpecifier(importDeclarations, importName) ?? {};\n\n  const injectImportDeclarations =\n    getImportDeclarations(sourceCode.ast, '@angular/core') ?? [];\n\n  const { importSpecifier: injectImportSpecifier } =\n    getImportDeclarationSpecifier(injectImportDeclarations, 'inject') ?? {};\n\n  if (!importSpecifier) {\n    return { sourceCode };\n  }\n\n  const variables = context.getDeclaredVariables(importSpecifier);\n  const typedVariable = variables.find(({ name }) => name === importName);\n  const identifiers = typedVariable?.references?.reduce<\n    readonly InjectedParameter[]\n  >((identifiers, { identifier: { parent } }) => {\n    if (!parent) {\n      return identifiers;\n    }\n\n    if (\n      isTSTypeReference(parent) &&\n      parent.parent &&\n      isTSTypeAnnotation(parent.parent) &&\n      parent.parent.parent &&\n      isIdentifier(parent.parent.parent)\n    ) {\n      return identifiers.concat(parent.parent.parent as InjectedParameter);\n    }\n\n    const parentToCheck = isTSInstantiationExpression(parent)\n      ? parent.parent\n      : parent;\n\n    if (\n      parentToCheck &&\n      isCallExpression(parentToCheck) &&\n      isIdentifier(parentToCheck.callee) &&\n      parentToCheck.callee.name == 'inject' &&\n      parentToCheck.parent &&\n      isPropertyDefinition(parentToCheck.parent) &&\n      isIdentifier(parentToCheck.parent.key) &&\n      injectImportSpecifier\n    ) {\n      return identifiers.concat(parentToCheck.parent.key as InjectedParameter);\n    }\n\n    return identifiers;\n  }, []);\n  return { identifiers, sourceCode };\n}\n\nexport function getNgRxEffectActions(\n  context: TSESLint.RuleContext<string, readonly unknown[]>\n): InjectedParameterWithSourceCode {\n  return getInjectedParametersWithSourceCode(\n    context,\n    NGRX_MODULE_PATHS.effects,\n    'Actions'\n  );\n}\n\nexport function getNgRxComponentStores(\n  context: TSESLint.RuleContext<string, readonly unknown[]>\n): InjectedParameterWithSourceCode {\n  return getInjectedParametersWithSourceCode(\n    context,\n    NGRX_MODULE_PATHS['component-store'],\n    'ComponentStore'\n  );\n}\n\nexport function getNgRxStores(\n  context: TSESLint.RuleContext<string, readonly unknown[]>\n): InjectedParameterWithSourceCode {\n  return getInjectedParametersWithSourceCode(\n    context,\n    NGRX_MODULE_PATHS.store,\n    'Store'\n  );\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping\nexport function escapeText(text: string): string {\n  return text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nexport function asPattern(identifiers: readonly InjectedParameter[]): RegExp {\n  const escapedNames = identifiers.map(({ name }) => escapeText(name));\n  return new RegExp(`^(${escapedNames.join('|')})$`);\n}\n"]}